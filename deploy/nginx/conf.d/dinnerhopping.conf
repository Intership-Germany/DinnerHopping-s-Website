server {
    listen 443 ssl;
    server_name dinnerhopping.com;

    ssl_certificate /etc/nginx/certs/dev.crt;
    ssl_certificate_key /etc/nginx/certs/dev.key;

    # Proxy API calls to the backend container and strip the /api prefix
    location /api/ {
        # rewrite so backend sees paths without the /api prefix, e.g. /api/docus -> /docus
        rewrite ^/api/(.*)$ /$1 break;
        proxy_pass http://backend:8000;
        # If backend issues redirects (Location headers) that point to the app root
        # (e.g. https://dinnerhopping.com/docus), rewrite them to include /api so
        # the client stays under /api (e.g. /api/docus).
        proxy_redirect https://$host/ /api/;
        proxy_redirect / /api/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;
    proxy_set_header X-Forwarded-Port 443;
    }

    # Proxy all other requests to a local frontend dev server running on the host
    location / {
        # Use Docker's host.docker.internal to reach the host machine from inside the container
        proxy_pass http://host.docker.internal:3000/;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_intercept_errors on;
        error_page 502 = @frontend_down;
    }

    location @frontend_down {
        add_header Content-Type text/html;
        return 200 '<html><body><h1>Frontend not running</h1><p>The frontend dev server is not available on port 3000.</p></body></html>';
    }
}
