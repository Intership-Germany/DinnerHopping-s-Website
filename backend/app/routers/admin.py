from fastapi import APIRouter, HTTPException, Depends
from .. import db as db_mod
from ..auth import require_admin
from pydantic import BaseModel, Field
from typing import List, Optional

router = APIRouter()

@router.post('/match')
async def run_match(_=Depends(require_admin)):
    """Idempotent admin matching: create per-user plans for each event's registrations.

    - Groups registrations in chunks of 6 and assigns three sections per user.
    - Removes existing plan documents for (event_id, user_email) before inserting.
    - Enriches host entries with lat/lon from `users` when available.
    """
    # current_user has been validated by the require_admin dependency

    async for event in db_mod.db.events.find({}):
        regs = []
        async for r in db_mod.db.registrations.find({"event_id": event['_id']}):
            regs.append(r)

        # group into chunks of 6
        chunks = [regs[i:i + 6] for i in range(0, len(regs), 6)]

        for chunk in chunks:
            users = [r['user_email'] for r in chunk]
            if not users:
                continue

            for idx, user_email in enumerate(users):
                # make matching idempotent by removing old plans for this user/event
                await db_mod.db.plans.delete_many({"event_id": event['_id'], "user_email": user_email})

                plan = {"event_id": event['_id'], "user_email": user_email, "sections": []}

                for meal_idx in range(3):
                    host_idx = (idx + meal_idx) % len(users)
                    host_email = users[host_idx]
                    guests = [u for u in users if u != host_email][:4]

                    host_profile = await db_mod.db.users.find_one({"email": host_email})
                    host_lat = host_profile.get('lat') if host_profile else None
                    host_lon = host_profile.get('lon') if host_profile else None

                    section = {
                        'meal': ['Entr\u00e9e', 'Plat Principal', 'Dessert'][meal_idx],
                        'time': '20:00' if meal_idx == 1 else ('18:00' if meal_idx == 0 else '22:00'),
                        'host': {'email': host_email, 'lat': host_lat, 'lon': host_lon},
                        'guests': guests,
                    }

                    plan['sections'].append(section)

                dt = __import__('datetime').datetime
                plan['created_at'] = dt.now(dt.timezone.utc)
                await db_mod.db.plans.insert_one(plan)

    # NOTE: MATCHES collection (schema: {event_id, groups:[...], status, version, finalized_by, finalized_at, created_at})
    # is not yet generated by this simple matching algorithm. Future implementation
    # could aggregate the above per-event plans into a single matches document.

    return {"status": "matching_completed"}


@router.post('/promote')
async def promote_user(email: str, _=Depends(require_admin)):
    """Grant the 'admin' role to a user identified by email.

    Only callable by existing admins. Returns the updated user doc (safe fields).
    """
    if not email:
        raise HTTPException(status_code=400, detail='email required')
    email = email.lower()
    user = await db_mod.db.users.find_one({'email': email})
    if not user:
        raise HTTPException(status_code=404, detail='User not found')
    roles = user.get('roles') or []
    if 'admin' in roles:
        return {'status': 'already_admin', 'email': email}
    roles = list(set(roles + ['admin']))
    _dt = __import__('datetime')
    await db_mod.db.users.update_one({'email': email}, {'$set': {'roles': roles, 'updated_at': _dt.datetime.now(_dt.timezone.utc)}})
    return {'status': 'promoted', 'email': email}


@router.post('/demote')
async def demote_user(email: str, _=Depends(require_admin)):
    """Revoke the 'admin' role from a user identified by email.

    Protects against demoting the last admin (requires at least one admin to remain).
    """
    if not email:
        raise HTTPException(status_code=400, detail='email required')
    email = email.lower()
    user = await db_mod.db.users.find_one({'email': email})
    if not user:
        raise HTTPException(status_code=404, detail='User not found')
    roles = user.get('roles') or []
    if 'admin' not in roles:
        return {'status': 'not_admin', 'email': email}

    # ensure at least one admin remains
    admin_count = await db_mod.db.users.count_documents({'roles': 'admin'})
    if admin_count <= 1:
        # if this is the last admin, prevent demotion to avoid lockout
        raise HTTPException(status_code=400, detail='Cannot demote the last admin')

    new_roles = [r for r in roles if r != 'admin']
    _dt = __import__('datetime')
    await db_mod.db.users.update_one({'email': email}, {'$set': {'roles': new_roles, 'updated_at': _dt.datetime.now(_dt.timezone.utc)}})
    return {'status': 'demoted', 'email': email}


class EmailTemplateIn(BaseModel):
    key: str = Field(..., pattern=r"^[a-zA-Z0-9_\-\.]+$", description="Unique template key, e.g. verification_reminder")
    subject: str
    html_body: str
    description: Optional[str] = None
    variables: List[str] | None = None  # list of allowed placeholder variable names

class EmailTemplateOut(EmailTemplateIn):
    id: str | None = None
    updated_at: str | None = None

@router.get('/email-templates', response_model=List[EmailTemplateOut])
async def list_email_templates(_=Depends(require_admin)):
    out = []
    cursor = db_mod.db.email_templates.find({})
    # If the collection is empty, seed a small set of default templates so
    # the admin UI is useful out-of-the-box. This mirrors `scripts/seed_email_templates.py`
    # but kept local to avoid import cycles and to run idempotently on first list.
    try:
        count = await db_mod.db.email_templates.count_documents({})
    except Exception:
        # Some fake/test DB implementations may not implement count_documents
        count = None
    if not count:
        DEFAULT_TEMPLATES = [
            {
                'key': 'verification_reminder',
                'subject': '',
                'html_body': "",
                'description': 'Sent to users who have not yet verified their email.',
                'variables': ['email']
            },
            {
                'key': 'payment_confirmation',
                'subject': '',
                'html_body': '',
                'description': 'Payment / registration confirmation',
                'variables': ['event_title','event_date','email']
            },
            {
                'key': 'cancellation_confirmation',
                'subject': '',
                'html_body': "",
                'description': 'Registration cancellation notice',
                'variables': ['event_title','refund','email']
            }
            ,{
                'key': 'invitation',
                'subject': "",
                'html_body': "",
                'description': 'Invitation email with accept link',
                'variables': ['invitation_link','email','temp_password']
            },
            {
                'key': 'invitation_accept',
                'subject': '',
                'html_body': '',
                'description': 'Notify inviter that invitation was accepted',
                'variables': ['registration_id','email']
            },
            {
                'key': 'password_reset',
                'subject': '',
                'html_body': "",
                'description': 'Password reset email',
                'variables': ['reset_url','email']
            },
            {
                'key': 'team_invitation',
                'subject': '',
                'html_body': "",
                'description': 'Team invitation email (partner)',
                'variables': ['event_title','decline_link','email']
            }
            ,{
                'key': 'email_verification',
                'subject': '',
                'html_body': "",
                'description': 'Initial verification email with a link to verify the address.',
                'variables': ['verification_url','email']
            }
        ]
        from datetime import datetime
        for tpl in DEFAULT_TEMPLATES:
            existing = await db_mod.db.email_templates.find_one({'key': tpl['key']})
            if existing:
                continue
            tpl['updated_at'] = datetime.utcnow()
            # Best-effort insert; ignore errors to keep listing functional
            try:
                await db_mod.db.email_templates.insert_one(tpl)
            except Exception:
                pass
    # Some test fakes return cursors that don't support sort(); handle gracefully
    try:
        cursor = cursor.sort('key', 1)
    except Exception:
        pass
    async for t in cursor:
        t['id'] = str(t.get('_id'))
        _val = t.get('updated_at')
        if isinstance(_val, str):
            t['updated_at'] = _val
        elif _val:
            try:
                t['updated_at'] = _val.isoformat()
            except Exception:
                t['updated_at'] = str(_val)
        else:
            t['updated_at'] = None
        # Use Pydantic v2 API when available: model_fields
        allowed = set(getattr(EmailTemplateOut, 'model_fields', getattr(EmailTemplateOut, '__fields__', {})).keys())
        out.append(EmailTemplateOut(**{k: v for k,v in t.items() if k in allowed}))
    return out

@router.get('/email-templates/{key}', response_model=EmailTemplateOut)
async def get_email_template(key: str, _=Depends(require_admin)):
    t = await db_mod.db.email_templates.find_one({'key': key})
    if not t:
        raise HTTPException(status_code=404, detail='Template not found')
    t['id'] = str(t.get('_id'))
    _val = t.get('updated_at')
    if isinstance(_val, str):
        t['updated_at'] = _val
    elif _val:
        try:
            t['updated_at'] = _val.isoformat()
        except Exception:
            t['updated_at'] = str(_val)
    else:
        t['updated_at'] = None
    # Use Pydantic v2 API when available: model_fields
    allowed = set(getattr(EmailTemplateOut, 'model_fields', getattr(EmailTemplateOut, '__fields__', {})).keys())
    return EmailTemplateOut(**{k: v for k,v in t.items() if k in allowed})

@router.post('/email-templates', response_model=EmailTemplateOut)
async def create_email_template(payload: EmailTemplateIn, _=Depends(require_admin)):
    existing = await db_mod.db.email_templates.find_one({'key': payload.key})
    if existing:
        raise HTTPException(status_code=400, detail='Template key already exists')
    # Prefer model_dump for Pydantic v2; fallback to dict() for older versions
    doc = getattr(payload, 'model_dump', getattr(payload, 'dict'))()
    _dt = __import__('datetime')
    doc['updated_at'] = _dt.datetime.now(_dt.timezone.utc)
    await db_mod.db.email_templates.insert_one(doc)
    doc['id'] = str(doc.get('_id', ''))
    doc['updated_at'] = doc['updated_at'].isoformat()
    allowed = set(getattr(EmailTemplateOut, 'model_fields', getattr(EmailTemplateOut, '__fields__', {})).keys())
    return EmailTemplateOut(**{k: v for k,v in doc.items() if k in allowed})

@router.put('/email-templates/{key}', response_model=EmailTemplateOut)
async def update_email_template(key: str, payload: EmailTemplateIn, _=Depends(require_admin)):
    if key != payload.key:
        # enforce key immutability
        raise HTTPException(status_code=400, detail='Key mismatch; cannot change key')
    # Prefer model_dump for Pydantic v2; fallback to dict() for older versions
    doc = getattr(payload, 'model_dump', getattr(payload, 'dict'))()
    _dt = __import__('datetime')
    doc['updated_at'] = _dt.datetime.now(_dt.timezone.utc)
    # FakeCollection.update_one used in tests does not accept an 'upsert' kwarg,
    # so call the basic two-arg form for compatibility.
    res = await db_mod.db.email_templates.update_one({'key': key}, {'$set': doc})
    if res.matched_count == 0:
        raise HTTPException(status_code=404, detail='Template not found')
    stored = await db_mod.db.email_templates.find_one({'key': key})
    stored['id'] = str(stored.get('_id'))
    _val = stored.get('updated_at')
    if isinstance(_val, str):
        stored['updated_at'] = _val
    elif _val:
        try:
            stored['updated_at'] = _val.isoformat()
        except Exception:
            stored['updated_at'] = str(_val)
    else:
        stored['updated_at'] = None
    # Use Pydantic v2 API when available: model_fields
    allowed = set(getattr(EmailTemplateOut, 'model_fields', getattr(EmailTemplateOut, '__fields__', {})).keys())
    return EmailTemplateOut(**{k: v for k,v in stored.items() if k in allowed})

@router.delete('/email-templates/{key}')
async def delete_email_template(key: str, _=Depends(require_admin)):
    res = await db_mod.db.email_templates.delete_one({'key': key})
    if res.deleted_count == 0:
        raise HTTPException(status_code=404, detail='Template not found')
    return {'status': 'deleted', 'key': key}
