from fastapi import APIRouter, HTTPException, Depends
from .. import db as db_mod
from ..auth import require_admin
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
import datetime
from bson.objectid import ObjectId

from .. import utils
from ..utils import finalize_registration_payment

router = APIRouter()

@router.post('/match')
async def run_match(_=Depends(require_admin)):
    """Idempotent admin matching: create per-user plans for each event's registrations.

    - Groups registrations in chunks of 6 and assigns three sections per user.
    - Removes existing plan documents for (event_id, user_email) before inserting.
    - Enriches host entries with lat/lon from `users` when available.
    """
    # current_user has been validated by the require_admin dependency

    async for event in db_mod.db.events.find({}):
        regs = []
        async for r in db_mod.db.registrations.find({"event_id": event['_id']}):
            regs.append(r)

        # group into chunks of 6
        chunks = [regs[i:i + 6] for i in range(0, len(regs), 6)]

        for chunk in chunks:
            users = [r['user_email'] for r in chunk]
            if not users:
                continue

            for idx, user_email in enumerate(users):
                # make matching idempotent by removing old plans for this user/event
                await db_mod.db.plans.delete_many({"event_id": event['_id'], "user_email": user_email})

                plan = {"event_id": event['_id'], "user_email": user_email, "sections": []}

                for meal_idx in range(3):
                    host_idx = (idx + meal_idx) % len(users)
                    host_email = users[host_idx]
                    guests = [u for u in users if u != host_email][:4]

                    host_profile = await db_mod.db.users.find_one({"email": host_email})
                    host_lat = host_profile.get('lat') if host_profile else None
                    host_lon = host_profile.get('lon') if host_profile else None

                    section = {
                        'meal': ['Entr\u00e9e', 'Plat Principal', 'Dessert'][meal_idx],
                        'time': '20:00' if meal_idx == 1 else ('18:00' if meal_idx == 0 else '22:00'),
                        'host': {'email': host_email, 'lat': host_lat, 'lon': host_lon},
                        'guests': guests,
                    }

                    plan['sections'].append(section)

                dt = __import__('datetime').datetime
                plan['created_at'] = dt.now(dt.timezone.utc)
                await db_mod.db.plans.insert_one(plan)

    # NOTE: MATCHES collection (schema: {event_id, groups:[...], status, version, finalized_by, finalized_at, created_at})
    # is not yet generated by this simple matching algorithm. Future implementation
    # could aggregate the above per-event plans into a single matches document.

    return {"status": "matching_completed"}


@router.post('/promote')
async def promote_user(email: str, _=Depends(require_admin)):
    """Grant the 'admin' role to a user identified by email.

    Only callable by existing admins. Returns the updated user doc (safe fields).
    """
    if not email:
        raise HTTPException(status_code=400, detail='email required')
    email = email.lower()
    user = await db_mod.db.users.find_one({'email': email})
    if not user:
        raise HTTPException(status_code=404, detail='User not found')
    roles = user.get('roles') or []
    if 'admin' in roles:
        return {'status': 'already_admin', 'email': email}
    roles = list(set(roles + ['admin']))
    _dt = __import__('datetime')
    await db_mod.db.users.update_one({'email': email}, {'$set': {'roles': roles, 'updated_at': _dt.datetime.now(_dt.timezone.utc)}})
    return {'status': 'promoted', 'email': email}


@router.post('/demote')
async def demote_user(email: str, _=Depends(require_admin)):
    """Revoke the 'admin' role from a user identified by email.

    Protects against demoting the last admin (requires at least one admin to remain).
    """
    if not email:
        raise HTTPException(status_code=400, detail='email required')
    email = email.lower()
    user = await db_mod.db.users.find_one({'email': email})
    if not user:
        raise HTTPException(status_code=404, detail='User not found')
    roles = user.get('roles') or []
    if 'admin' not in roles:
        return {'status': 'not_admin', 'email': email}

    # ensure at least one admin remains
    admin_count = await db_mod.db.users.count_documents({'roles': 'admin'})
    if admin_count <= 1:
        # if this is the last admin, prevent demotion to avoid lockout
        raise HTTPException(status_code=400, detail='Cannot demote the last admin')

    new_roles = [r for r in roles if r != 'admin']
    _dt = __import__('datetime')
    await db_mod.db.users.update_one({'email': email}, {'$set': {'roles': new_roles, 'updated_at': _dt.datetime.now(_dt.timezone.utc)}})
    return {'status': 'demoted', 'email': email}


class EmailTemplateIn(BaseModel):
    key: str = Field(..., pattern=r"^[a-zA-Z0-9_\-\.]+$", description="Unique template key, e.g. verification_reminder")
    subject: str
    html_body: str
    description: Optional[str] = None
    variables: List[str] | None = None  # list of allowed placeholder variable names

class EmailTemplateOut(EmailTemplateIn):
    id: str | None = None
    updated_at: str | None = None

@router.get('/email-templates', response_model=List[EmailTemplateOut])
async def list_email_templates(_=Depends(require_admin)):
    out = []
    cursor = db_mod.db.email_templates.find({})
    # If the collection is empty, seed a small set of default templates so
    # the admin UI is useful out-of-the-box. This mirrors `scripts/seed_email_templates.py`
    # but kept local to avoid import cycles and to run idempotently on first list.
    try:
        count = await db_mod.db.email_templates.count_documents({})
    except Exception:
        # Some fake/test DB implementations may not implement count_documents
        count = None
    if not count:
        DEFAULT_TEMPLATES = [
            {
                'key': 'verification_reminder',
                'subject': '',
                'html_body': "",
                'description': 'Sent to users who have not yet verified their email.',
                'variables': ['email']
            },
            {
                'key': 'payment_confirmation',
                'subject': '',
                'html_body': '',
                'description': 'Payment / registration confirmation',
                'variables': ['event_title','event_date','email']
            },
            {
                'key': 'cancellation_confirmation',
                'subject': '',
                'html_body': "",
                'description': 'Registration cancellation notice',
                'variables': ['event_title','refund','email']
            },
            {
                'key': 'invitation',
                'subject': "",
                'html_body': "",
                'description': 'Invitation email with accept link',
                'variables': ['invitation_link','email','set_password_url']
            },
            {
                'key': 'invitation_accept',
                'subject': '',
                'html_body': '',
                'description': 'Notify inviter that invitation was accepted',
                'variables': ['registration_id','email']
            },
            {
                'key': 'password_reset',
                'subject': '',
                'html_body': "",
                'description': 'Password reset email',
                'variables': ['reset_url','email']
            },
            {
                'key': 'team_invitation',
                'subject': '',
                'html_body': "",
                'description': 'Team invitation email (partner)',
                'variables': ['event_title','decline_link','email']
            },
            {
                'key': 'email_verification',
                'subject': '',
                'html_body': "",
                'description': 'Initial verification email with a link to verify the address.',
                'variables': ['verification_url','email']
            },
            {
                'key': 'final_plan',
                'subject': '',
                'html_body': '',
                'description': 'Final plan release notification',
                'variables': ['event_title','email']
            },
            {
                'key': 'refund_processed',
                'subject': '',
                'html_body': '',
                'description': 'Sent to a participant when a cancellation refund is processed',
                'variables': ['event_title','amount_eur','email']
            },
            {
                'key': 'team_incomplete_reminder',
                'subject': '',
                'html_body': '',
                'description': 'Reminder to team creator to find a replacement partner',
                'variables': ['event_title','replace_url','email']
            },
            {
                'key': 'team_partner_cancelled',
                'subject': '',
                'html_body': '',
                'description': 'Notification that team partner has cancelled',
                'variables': ['event_title','email']
            },
            {
                'key': 'team_replacement',
                'subject': '',
                'html_body': '',
                'description': 'Notification for replacement partner joining team',
                'variables': ['event_title','email']
            }
        ]
        for tpl in DEFAULT_TEMPLATES:
            existing = await db_mod.db.email_templates.find_one({'key': tpl['key']})
            if existing:
                continue
            tpl['updated_at'] = datetime.datetime.utcnow()
            # Best-effort insert; ignore errors to keep listing functional
            try:
                await db_mod.db.email_templates.insert_one(tpl)
            except Exception:
                pass
    # Some test fakes return cursors that don't support sort(); handle gracefully
    try:
        cursor = cursor.sort('key', 1)
    except Exception:
        pass
    async for t in cursor:
        t['id'] = str(t.get('_id'))
        _val = t.get('updated_at')
        if isinstance(_val, str):
            t['updated_at'] = _val
        elif _val:
            try:
                t['updated_at'] = _val.isoformat()
            except Exception:
                t['updated_at'] = str(_val)
        else:
            t['updated_at'] = None
        # Use Pydantic v2 API when available: model_fields
        allowed = set(getattr(EmailTemplateOut, 'model_fields', getattr(EmailTemplateOut, '__fields__', {})).keys())
        out.append(EmailTemplateOut(**{k: v for k,v in t.items() if k in allowed}))
    return out

    @router.get('/alerts')
    async def list_admin_alerts(_=Depends(require_admin)):
        """List admin_alerts for the dashboard."""
        out = []
        try:
            cursor = db_mod.db.admin_alerts.find({}).sort('created_at', -1)
        except Exception:
            cursor = db_mod.db.admin_alerts.find({})
        async for a in cursor:
            a['id'] = str(a.get('_id'))
            out.append(a)
        return out

    @router.post('/alerts/{alert_id}/close')
    async def close_admin_alert(alert_id: str, _=Depends(require_admin)):
        try:
            oid = ObjectId(alert_id)
        except Exception:
            raise HTTPException(status_code=400, detail='invalid alert id')
        res = await db_mod.db.admin_alerts.update_one({'_id': oid}, {'$set': {'status': 'closed', 'closed_at': datetime.datetime.utcnow()}})
        if res.matched_count == 0:
            raise HTTPException(status_code=404, detail='alert not found')
        return {'status': 'closed'}

    @router.post('/alerts/{alert_id}/confirm_payment')
    async def admin_confirm_alert_payment(alert_id: str, _=Depends(require_admin)):
        """Admin action: confirm payment referenced by alert and finalize registration.

        This performs the same action as the payments.confirm endpoint but is convenient
        to be called from the admin dashboard.
        """
        try:
            oid = ObjectId(alert_id)
        except Exception:
            raise HTTPException(status_code=400, detail='invalid alert id')
        alert = await db_mod.db.admin_alerts.find_one({'_id': oid})
        if not alert:
            raise HTTPException(status_code=404, detail='alert not found')
        payment_id = alert.get('payment_id')
        if not payment_id:
            raise HTTPException(status_code=400, detail='no payment linked to alert')
        try:
            pay_oid = ObjectId(payment_id)
        except Exception:
            raise HTTPException(status_code=400, detail='invalid payment id stored')
        pay = await db_mod.db.payments.find_one({'_id': pay_oid})
        if not pay:
            raise HTTPException(status_code=404, detail='payment not found')
        if (pay.get('status') or '').lower() in ('succeeded', 'paid'):
            # ensure alert closed
            await db_mod.db.admin_alerts.update_one({'_id': oid}, {'$set': {'status': 'closed', 'closed_at': datetime.datetime.utcnow()}})
            return {'status': 'already_paid'}

        now = datetime.datetime.utcnow()
        await db_mod.db.payments.update_one({'_id': pay_oid}, {'$set': {'status': 'succeeded', 'paid_at': now, 'meta.admin_confirmed_by': 'admin_dashboard'}})
        # finalize registration
        try:
            await finalize_registration_payment(pay.get('registration_id'), pay.get('_id'))
        except Exception:
            pass
        await db_mod.db.admin_alerts.update_one({'_id': oid}, {'$set': {'status': 'closed', 'closed_at': now}})
        return {'status': 'succeeded'}
@router.get('/email-templates/{key}', response_model=EmailTemplateOut)
async def get_email_template(key: str, _=Depends(require_admin)):
    t = await db_mod.db.email_templates.find_one({'key': key})
    if not t:
        raise HTTPException(status_code=404, detail='Template not found')
    t['id'] = str(t.get('_id'))
    _val = t.get('updated_at')
    if isinstance(_val, str):
        t['updated_at'] = _val
    elif _val:
        try:
            t['updated_at'] = _val.isoformat()
        except Exception:
            t['updated_at'] = str(_val)
    else:
        t['updated_at'] = None
    # Use Pydantic v2 API when available: model_fields
    allowed = set(getattr(EmailTemplateOut, 'model_fields', getattr(EmailTemplateOut, '__fields__', {})).keys())
    return EmailTemplateOut(**{k: v for k,v in t.items() if k in allowed})

@router.post('/email-templates', response_model=EmailTemplateOut)
async def create_email_template(payload: EmailTemplateIn, _=Depends(require_admin)):
    existing = await db_mod.db.email_templates.find_one({'key': payload.key})
    if existing:
        raise HTTPException(status_code=400, detail='Template key already exists')
    # Prefer model_dump for Pydantic v2; fallback to dict() for older versions
    doc = getattr(payload, 'model_dump', getattr(payload, 'dict'))()
    _dt = __import__('datetime')
    doc['updated_at'] = _dt.datetime.now(_dt.timezone.utc)
    await db_mod.db.email_templates.insert_one(doc)
    doc['id'] = str(doc.get('_id', ''))
    doc['updated_at'] = doc['updated_at'].isoformat()
    allowed = set(getattr(EmailTemplateOut, 'model_fields', getattr(EmailTemplateOut, '__fields__', {})).keys())
    return EmailTemplateOut(**{k: v for k,v in doc.items() if k in allowed})

@router.put('/email-templates/{key}', response_model=EmailTemplateOut)
async def update_email_template(key: str, payload: EmailTemplateIn, _=Depends(require_admin)):
    if key != payload.key:
        # enforce key immutability
        raise HTTPException(status_code=400, detail='Key mismatch; cannot change key')
    # Prefer model_dump for Pydantic v2; fallback to dict() for older versions
    doc = getattr(payload, 'model_dump', getattr(payload, 'dict'))()
    _dt = __import__('datetime')
    doc['updated_at'] = _dt.datetime.now(_dt.timezone.utc)
    # FakeCollection.update_one used in tests does not accept an 'upsert' kwarg,
    # so call the basic two-arg form for compatibility.
    res = await db_mod.db.email_templates.update_one({'key': key}, {'$set': doc})
    if res.matched_count == 0:
        raise HTTPException(status_code=404, detail='Template not found')
    stored = await db_mod.db.email_templates.find_one({'key': key})
    stored['id'] = str(stored.get('_id'))
    _val = stored.get('updated_at')
    if isinstance(_val, str):
        stored['updated_at'] = _val
    elif _val:
        try:
            stored['updated_at'] = _val.isoformat()
        except Exception:
            stored['updated_at'] = str(_val)
    else:
        stored['updated_at'] = None
    # Use Pydantic v2 API when available: model_fields
    allowed = set(getattr(EmailTemplateOut, 'model_fields', getattr(EmailTemplateOut, '__fields__', {})).keys())
    return EmailTemplateOut(**{k: v for k,v in stored.items() if k in allowed})

@router.delete('/email-templates/{key}')
async def delete_email_template(key: str, _=Depends(require_admin)):
    res = await db_mod.db.email_templates.delete_one({'key': key})
    if res.deleted_count == 0:
        raise HTTPException(status_code=404, detail='Template not found')
    return {'status': 'deleted', 'key': key}


# ---------------- Admin: Chat management ----------------
@router.get('/chats')
async def admin_list_chats(event_id: str | None = None, _=Depends(require_admin)):
    """List chat groups. If event_id provided, filter by that event."""
    q = {}
    if event_id:
        q['event_id'] = event_id
    out = []
    async for g in db_mod.db.chat_groups.find(q).sort('created_at', 1):
        out.append({
            '_id': str(g.get('_id')),
            'event_id': g.get('event_id'),
            'section_ref': g.get('section_ref'),
            'participant_emails': g.get('participant_emails', []),
            'created_at': g.get('created_at').isoformat() if g.get('created_at') else None,
            'created_by': g.get('created_by')
        })
    return out


@router.post('/chats/seed')
async def admin_seed_chats(event_id: str = None, _=Depends(require_admin)):
    """Seed chat groups for an event (create groups for teams and a general group for solo registrants).

    If event_id omitted, seeds for all events.
    """
    if not event_id:
        return {'status': 'event_id required'}
    # best-effort: create groups per team
    try:
        # create per-team groups
        async for t in db_mod.db.teams.find({'event_id': ObjectId(event_id)}):
            # collect member emails
            member_emails = []
            async for r in db_mod.db.registrations.find({'event_id': ObjectId(event_id), 'team_id': t.get('_id')}):
                email = r.get('user_email_snapshot') or r.get('user_email')
                if email:
                    member_emails.append(email.lower())
            if member_emails:
                await utils.create_chat_group(event_id, member_emails, created_by='admin@system', section_ref='team')

        # ensure a general group including all active registrants
        try:
            from app.utils import ensure_general_chat_full
            await ensure_general_chat_full(event_id)
        except Exception:
            pass
        # create per-dinner chats if a match exists
        try:
            from app.utils import ensure_chats_from_matches
            await ensure_chats_from_matches(event_id)
        except Exception:
            pass
        return {'status': 'seeded'}
    except Exception:
        return {'status': 'error'}


@router.post('/chats/clear')
async def admin_clear_chats(event_id: str = None, _=Depends(require_admin)):
    """Delete chat groups for an event."""
    if not event_id:
        return {'status': 'event_id required'}
    try:
        # First find group ids for the event so we can delete messages
        group_ids = []
        async for g in db_mod.db.chat_groups.find({'event_id': event_id}, {'_id': 1}):
            group_ids.append(str(g.get('_id')))
        msg_deleted = 0
        if group_ids:
            try:
                mr = await db_mod.db.chat_messages.delete_many({'group_id': {'$in': group_ids}})
                msg_deleted = getattr(mr, 'deleted_count', 0)
            except Exception:
                msg_deleted = 0
        gr = await db_mod.db.chat_groups.delete_many({'event_id': event_id})
        return {'groups_deleted': getattr(gr, 'deleted_count', 0), 'messages_deleted': msg_deleted}
    except Exception:
        return {'groups_deleted': 0, 'messages_deleted': 0}


@router.delete('/chats/groups/{group_id}')
async def admin_delete_group(group_id: str, _=Depends(require_admin)):
    try:
        oid = ObjectId(group_id)
    except Exception:
        raise HTTPException(status_code=400, detail='Invalid group id')
    res = await db_mod.db.chat_groups.delete_one({'_id': oid})
    if getattr(res, 'deleted_count', 0) == 0:
        raise HTTPException(status_code=404, detail='Group not found')
    # also delete messages for the group
    try:
        await db_mod.db.chat_messages.delete_many({'group_id': group_id})
    except Exception:
        pass
    return {'status': 'deleted', 'group_id': group_id}


@router.get('/chats/groups/{group_id}')
async def admin_get_group(group_id: str, _=Depends(require_admin)):
    try:
        oid = ObjectId(group_id)
    except Exception:
        raise HTTPException(status_code=400, detail='Invalid group id')
    g = await db_mod.db.chat_groups.find_one({'_id': oid})
    if not g:
        raise HTTPException(status_code=404, detail='Group not found')
    return {
        '_id': str(g.get('_id')),
        'event_id': g.get('event_id'),
        'section_ref': g.get('section_ref'),
        'participant_emails': g.get('participant_emails', []),
        'created_at': g.get('created_at').isoformat() if g.get('created_at') else None,
        'created_by': g.get('created_by')
    }


@router.get('/chats/groups/{group_id}/messages')
async def admin_list_group_messages(group_id: str, _=Depends(require_admin)):
    msgs = []
    async for m in db_mod.db.chat_messages.find({'group_id': group_id}).sort('created_at', 1):
        msgs.append({
            'id': str(m.get('_id')),
            'group_id': m.get('group_id'),
            'body': m.get('body'),
            'created_at': m.get('created_at').isoformat() if m.get('created_at') else None,
            'sender_email': m.get('sender_email')
        })
    return msgs


@router.post('/chats/groups/{group_id}/messages')
async def admin_post_group_message(group_id: str, body: str, _=Depends(require_admin)):
    now = datetime.datetime.now(datetime.timezone.utc)
    doc = {
        'group_id': group_id,
        'sender_email': 'admin@system',
        'body': body,
        'created_at': now
    }
    res = await db_mod.db.chat_messages.insert_one(doc)
    return {'id': str(res.inserted_id), 'group_id': group_id, 'body': body, 'created_at': now.isoformat(), 'sender_email': 'admin@system'}


# ---------------- Admin: Team Management ----------------
@router.get('/teams/overview')
async def admin_teams_overview(event_id: str | None = None, _=Depends(require_admin)):
    """Get overview of all teams with status categorization.
    
    Returns teams categorized as:
    - complete: All members active and paid
    - incomplete: One member cancelled, needs replacement
    - faulty: Both members cancelled after payment/matching
    - pending: Awaiting payment or confirmation
    """
    query = {}
    if event_id:
        try:
            query['event_id'] = ObjectId(event_id)
        except Exception:
            raise HTTPException(status_code=400, detail='Invalid event_id')
    
    teams_list = []
    async for team in db_mod.db.teams.find(query):
        team_id = str(team.get('_id'))
        event_id_str = str(team.get('event_id'))
        
        # Get event info
        event = None
        try:
            event = await db_mod.db.events.find_one({'_id': team.get('event_id')})
        except Exception:
            pass
        
        # Get all registrations for this team
        registrations = []
        async for reg in db_mod.db.registrations.find({'team_id': team.get('_id')}):
            registrations.append(reg)
        
        # Categorize team status
        # Note: Partner registration is always 'confirmed' (no payment), creator has payment
        active_count = sum(1 for r in registrations if r.get('status') not in ('cancelled_by_user', 'cancelled_admin'))
        cancelled_count = sum(1 for r in registrations if r.get('status') in ('cancelled_by_user', 'cancelled_admin'))
        # Team is paid when creator (who has payment_id) has status 'paid'
        creator_paid = any(r.get('payment_id') and r.get('status') == 'paid' for r in registrations)
        
        category = 'pending'
        if team.get('status') == 'incomplete':
            category = 'incomplete'
        elif cancelled_count == 2:
            category = 'faulty'  # Both members cancelled
        elif active_count == 2 and creator_paid:
            category = 'complete'  # Both active and payment complete
        
        # Normalize members and any nested ObjectId values to JSON-safe types
        def _sanitize_value(v):
            try:
                # lazy import to avoid circulars in some test environments
                from bson.objectid import ObjectId as _OID
            except Exception:
                _OID = None
            if _OID and isinstance(v, _OID):
                return str(v)
            if isinstance(v, dict):
                out = {}
                for kk, vv in v.items():
                    out[kk] = _sanitize_value(vv)
                return out
            if isinstance(v, list):
                return [_sanitize_value(x) for x in v]
            return v

        raw_members = team.get('members', []) or []
        safe_members = _sanitize_value(raw_members)
        safe_cooking_location = _sanitize_value(team.get('cooking_location'))

        teams_list.append({
            'team_id': team_id,
            'event_id': event_id_str,
            'event_title': event.get('title') if event else 'Unknown',
            'status': team.get('status'),
            'category': category,
            'created_at': team.get('created_at').isoformat() if team.get('created_at') else None,
            'members': safe_members,
            'active_registrations': active_count,
            'cancelled_registrations': cancelled_count,
            'creator_paid': creator_paid,
            'cooking_location': safe_cooking_location,
            'course_preference': team.get('course_preference'),
            'team_diet': team.get('team_diet'),
        })
    
    return {
        'teams': teams_list,
        'total': len(teams_list),
        'complete': sum(1 for t in teams_list if t['category'] == 'complete'),
        'incomplete': sum(1 for t in teams_list if t['category'] == 'incomplete'),
        'faulty': sum(1 for t in teams_list if t['category'] == 'faulty'),
        'pending': sum(1 for t in teams_list if t['category'] == 'pending'),
    }


@router.post('/teams/send-incomplete-reminder')
async def admin_send_incomplete_team_reminders(event_id: str, _=Depends(require_admin)):
    """Send standardized email to all incomplete teams for an event.
    
    Reminds team creators to find a replacement partner before the event.
    """
    try:
        eid = ObjectId(event_id)
    except Exception:
        raise HTTPException(status_code=400, detail='Invalid event_id')
    
    event = await db_mod.db.events.find_one({'_id': eid})
    if not event:
        raise HTTPException(status_code=404, detail='Event not found')
    
    # Find all incomplete teams
    incomplete_teams = []
    async for team in db_mod.db.teams.find({'event_id': eid, 'status': 'incomplete'}):
        incomplete_teams.append(team)
    
    emails_sent = 0
    errors = []
    
    for team in incomplete_teams:
        # Find the creator's registration
        creator_reg = await db_mod.db.registrations.find_one({
            'team_id': team.get('_id'),
            'user_id': team.get('created_by_user_id'),
            'status': {'$nin': ['cancelled_by_user', 'cancelled_admin']}
        })
        
        if creator_reg and creator_reg.get('user_email_snapshot'):
            try:
                base = __import__('os').getenv('BACKEND_BASE_URL', 'http://localhost:8000')
                replace_url = f"{base}/registrations/teams/{str(team.get('_id'))}/replace"
                
                from app.utils import send_email
                success = await send_email(
                    to=creator_reg['user_email_snapshot'],
                    subject=f"Action needed: Find a replacement partner for {event.get('title')}",
                    body=(
                        f"Hi,\n\n"
                        f"Your team for '{event.get('title')}' is currently incomplete.\n"
                        f"Your partner has cancelled, and you need to find a replacement.\n\n"
                        f"Please visit: {replace_url}\n\n"
                        f"If you don't find a replacement, your team may be excluded from matching.\n\n"
                        f"Best regards,\nDinnerHopping Team"
                    ),
                    category='team_incomplete_reminder',
                    template_vars={
                        'event_title': event.get('title'),
                        'replace_url': replace_url,
                        'email': creator_reg['user_email_snapshot']
                    }
                )
                if success:
                    emails_sent += 1
            except Exception as e:
                errors.append(f"Failed to send to {creator_reg.get('user_email_snapshot')}: {str(e)}")
    
    return {
        'status': 'completed',
        'incomplete_teams_found': len(incomplete_teams),
        'emails_sent': emails_sent,
        'errors': errors
    }


@router.post('/teams/create-from-synthetic')
async def admin_create_team_from_synthetic(event_id: str, synthetic_id: str, _=Depends(require_admin)):
    """Create a persistent `teams` document from a synthetic unit id (pair:... or split:...).

    - Only affects registrations without an existing `team_id` (i.e. solos).
    - Returns created team id and how many registrations were attached.
    """
    try:
        eid = ObjectId(event_id)
    except Exception:
        raise HTTPException(status_code=400, detail='Invalid event_id')

    if not synthetic_id or not (synthetic_id.startswith('pair:') or synthetic_id.startswith('split:')):
        raise HTTPException(status_code=400, detail='synthetic_id must start with "pair:" or "split:"')

    # derive emails from synthetic id
    emails = []
    if synthetic_id.startswith('pair:'):
        payload = synthetic_id[len('pair:'):]
        emails = [p for p in payload.split('+') if p]
    else:
        payload = synthetic_id[len('split:'):]
        emails = [payload] if payload else []

    if not emails:
        raise HTTPException(status_code=400, detail='No participant emails could be derived from synthetic_id')

    # Find registrations matching these emails for the event and without a team_id
    regs = []
    lower_emails = [e.lower() for e in emails]
    async for r in db_mod.db.registrations.find({'event_id': eid}):
        em = (r.get('user_email_snapshot') or r.get('user_email') or '').lower()
        if em and any(le in em or em in le for le in lower_emails):
            # candidate
            regs.append(r)

    if not regs:
        raise HTTPException(status_code=404, detail='No matching solo registrations found for synthetic id')

    # Build team members from registrations (only those without existing team_id)
    members = []
    reg_ids_to_update = []
    for r in regs:
        if r.get('team_id'):
            # skip registrations already in a real team
            continue
        members.append({'type': 'user', 'user_id': r.get('user_id'), 'email': r.get('user_email_snapshot') or r.get('user_email')})
        reg_ids_to_update.append(r.get('_id'))

    if not members:
        raise HTTPException(status_code=400, detail='All matching registrations already belong to a team')

    now = datetime.datetime.utcnow()
    team_doc = {
        'event_id': eid,
        'created_by_user_id': None,
        'status': 'pending',
        'members': members,
        'cooking_location': None,
        'course_preference': None,
        'team_diet': None,
        'created_at': now,
        'origin': {'type': 'synthetic', 'synthetic_id': synthetic_id}
    }
    inserted = await db_mod.db.teams.insert_one(team_doc)
    team_id = inserted.inserted_id if inserted else None
    updated = 0
    if team_id and reg_ids_to_update:
        try:
            mr = await db_mod.db.registrations.update_many({'_id': {'$in': reg_ids_to_update}}, {'$set': {'team_id': team_id}})
            updated = getattr(mr, 'modified_count', 0) or getattr(mr, 'matched_count', 0) or 0
        except Exception:
            updated = 0

    return {'status': 'created', 'team_id': str(team_id) if team_id else None, 'members_attached': updated}


@router.post('/teams/{synthetic_id}/split')
async def admin_split_synthetic_team(synthetic_id: str, event_id: str, _=Depends(require_admin)):
    """Split a synthetic pair into separate single-member persistent teams.

    - For a `pair:...` synthetic id will create one team per underlying participant (single-member teams)
    - Updates only registrations without an existing team_id.
    """
    try:
        eid = ObjectId(event_id)
    except Exception:
        raise HTTPException(status_code=400, detail='Invalid event_id')

    if not synthetic_id or not synthetic_id.startswith('pair:'):
        raise HTTPException(status_code=400, detail='Only pair: synthetic ids are supported for split')

    payload = synthetic_id[len('pair:'):]
    emails = [p for p in payload.split('+') if p]
    if not emails:
        raise HTTPException(status_code=400, detail='No participant emails derived from synthetic id')

    created_team_ids = []
    attached_count = 0

    lower_emails = [e.lower() for e in emails]
    async for r in db_mod.db.registrations.find({'event_id': eid}):
        em = (r.get('user_email_snapshot') or r.get('user_email') or '').lower()
        if not em: continue
        match = any(le in em or em in le for le in lower_emails)
        if not match: continue
        if r.get('team_id'):
            # skip existing
            continue
        # create single-member team
        member = {'type': 'user', 'user_id': r.get('user_id'), 'email': r.get('user_email_snapshot') or r.get('user_email')}
        now = datetime.datetime.utcnow()
        team_doc = {
            'event_id': eid,
            'created_by_user_id': None,
            'status': 'pending',
            'members': [member],
            'cooking_location': None,
            'course_preference': None,
            'team_diet': None,
            'created_at': now,
            'origin': {'type': 'synthetic_split', 'synthetic_id': synthetic_id}
        }
        inserted = await db_mod.db.teams.insert_one(team_doc)
        tid = inserted.inserted_id if inserted else None
        if tid:
            created_team_ids.append(str(tid))
            try:
                await db_mod.db.registrations.update_one({'_id': r.get('_id')}, {'$set': {'team_id': tid}})
                attached_count += 1
            except Exception:
                pass

    if not created_team_ids:
        raise HTTPException(status_code=404, detail='No eligible solo registrations found to split')

    return {'status': 'split_completed', 'created_team_ids': created_team_ids, 'registrations_attached': attached_count}


@router.post('/events/{event_id}/release-plans')
async def admin_release_event_plans(event_id: str, _=Depends(require_admin)):
    """Send final event plans to all paid participants.
    
    Notifies all participants with paid status that their schedule is ready.
    """
    try:
        eid = ObjectId(event_id)
    except Exception:
        raise HTTPException(status_code=400, detail='Invalid event_id')
    
    event = await db_mod.db.events.find_one({'_id': eid})
    if not event:
        raise HTTPException(status_code=404, detail='Event not found')
    
    # Find all paid registrations
    paid_emails = set()
    async for reg in db_mod.db.registrations.find({'event_id': eid, 'status': 'paid'}):
        email = reg.get('user_email_snapshot')
        if email:
            paid_emails.add(email.lower())
    
    emails_sent = 0
    errors = []
    
    for email in paid_emails:
        try:
            from app.utils import send_email
            base = __import__('os').getenv('FRONTEND_BASE_URL', 'http://localhost:3000')
            plan_url = f"{base}/my-plan.html"
            
            success = await send_email(
                to=email,
                subject=f"Your DinnerHopping schedule is ready - {event.get('title')}",
                body=(
                    f"Hi,\n\n"
                    f"Great news! The final schedule for '{event.get('title')}' is now available.\n\n"
                    f"View your personal event plan here: {plan_url}\n\n"
                    f"See you soon!\nDinnerHopping Team"
                ),
                category='final_plan',
                template_vars={
                    'event_title': event.get('title'),
                    'plan_url': plan_url,
                    'email': email
                }
            )
            if success:
                emails_sent += 1
        except Exception as e:
            errors.append(f"Failed to send to {email}: {str(e)}")
    
    return {
        'status': 'completed',
        'participants_notified': emails_sent,
        'total_paid': len(paid_emails),
        'errors': errors
    }


def _strip_or_none(value: Any) -> Optional[str]:
    if value is None:
        return None
    text = str(value).strip()
    return text or None


def _split_name(value: Optional[str]) -> tuple[Optional[str], Optional[str]]:
    if not value:
        return (None, None)
    parts = [p for p in str(value).strip().split() if p]
    if not parts:
        return (None, None)
    if len(parts) == 1:
        return (parts[0], None)
    return (parts[0], ' '.join(parts[1:]))


def _isoformat(value: Any) -> Optional[str]:
    if value is None:
        return None
    if isinstance(value, str):
        return value
    try:
        if isinstance(value, datetime.datetime):
            if value.tzinfo is None:
                value = value.replace(tzinfo=datetime.timezone.utc)
            return value.isoformat()
        if isinstance(value, datetime.date):
            return value.isoformat()
    except Exception:
        return str(value)
    return str(value)


def _collect_team_label(team: Optional[dict], users_by_id: Dict[str, dict]) -> Optional[str]:
    if not team:
        return None
    members = team.get('members') or []
    labels: List[str] = []
    for entry in members:
        name = _strip_or_none(entry.get('name') or entry.get('display_name'))
        if not name and entry.get('user_id'):
            user = users_by_id.get(str(entry.get('user_id')))
            if user:
                fn = _strip_or_none(user.get('first_name') or user.get('firstname'))
                ln = _strip_or_none(user.get('last_name') or user.get('lastname'))
                name = ' '.join([p for p in [fn, ln] if p])
                if not name:
                    name = _strip_or_none(user.get('name'))
        if not name:
            name = _strip_or_none(entry.get('email'))
        if name:
            labels.append(name)
    if labels:
        return ' Ã— '.join(labels)
    return None


class ParticipantOut(BaseModel):
    registration_id: str
    event_id: str
    user_id: Optional[str] = None
    email: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    full_name: Optional[str] = None
    gender: Optional[str] = None
    phone_number: Optional[str] = None
    registration_status: Optional[str] = None
    payment_status: str
    payment_provider: Optional[str] = None
    payment_amount_cents: Optional[int] = None
    payment_currency: Optional[str] = None
    payment_id: Optional[str] = None
    payment_updated_at: Optional[str] = None
    team_id: Optional[str] = None
    team_role: Optional[str] = None
    team_status: Optional[str] = None
    team_name: Optional[str] = None
    diet: Optional[str] = None
    allergies: List[str] = Field(default_factory=list)
    created_at: Optional[str] = None
    updated_at: Optional[str] = None


class ParticipantsSummary(BaseModel):
    total: int
    by_payment_status: Dict[str, int] = Field(default_factory=dict)
    by_registration_status: Dict[str, int] = Field(default_factory=dict)


class ParticipantsResponse(BaseModel):
    event_id: str
    participants: List[ParticipantOut]
    summary: ParticipantsSummary


@router.get('/events/{event_id}/participants', response_model=ParticipantsResponse)
async def admin_event_participants(event_id: str, search: Optional[str] = None, _=Depends(require_admin)):
    try:
        event_oid = ObjectId(event_id)
    except Exception:
        raise HTTPException(status_code=400, detail='Invalid event_id')

    event = await db_mod.db.events.find_one({'_id': event_oid})
    if not event:
        raise HTTPException(status_code=404, detail='Event not found')

    registrations: List[dict] = []
    async for reg in db_mod.db.registrations.find({'event_id': event_oid}):
        registrations.append(reg)

    if not registrations:
        empty_summary = ParticipantsSummary(total=0)
        return ParticipantsResponse(event_id=event_id, participants=[], summary=empty_summary)

    reg_ids = [reg.get('_id') for reg in registrations if reg.get('_id')]
    user_ids: set[Any] = set()
    team_ids: set[Any] = set()
    for reg in registrations:
        if reg.get('user_id'):
            user_ids.add(reg['user_id'])
        if reg.get('team_id'):
            team_ids.add(reg['team_id'])

    teams: Dict[str, dict] = {}
    if team_ids:
        async for team in db_mod.db.teams.find({'_id': {'$in': list(team_ids)}}):
            teams[str(team.get('_id'))] = team
            for member in team.get('members', []) or []:
                if member.get('user_id'):
                    user_ids.add(member['user_id'])

    users_by_id: Dict[str, dict] = {}
    users_by_email: Dict[str, dict] = {}
    if user_ids:
        async for user in db_mod.db.users.find({'_id': {'$in': list(user_ids)}}):
            uid = str(user.get('_id'))
            users_by_id[uid] = user
            email = _strip_or_none(user.get('email'))
            if email:
                users_by_email[email.lower()] = user

    payments_by_registration: Dict[str, List[dict]] = {}
    if reg_ids:
        async for payment in db_mod.db.payments.find({'registration_id': {'$in': reg_ids}}):
            rid = payment.get('registration_id')
            if rid:
                payments_by_registration.setdefault(str(rid), []).append(payment)

    def resolve_member_snapshot(team_doc: Optional[dict], reg_doc: dict, user_doc: Optional[dict]) -> Optional[dict]:
        if not team_doc:
            return None
        members = team_doc.get('members') or []
        reg_uid = reg_doc.get('user_id')
        reg_uid_str = str(reg_uid) if reg_uid else None
        reg_email = _strip_or_none(reg_doc.get('user_email_snapshot') or (user_doc or {}).get('email'))
        reg_email_lower = reg_email.lower() if reg_email else None
        for member in members:
            mem_uid = member.get('user_id')
            if mem_uid and reg_uid_str and str(mem_uid) == reg_uid_str:
                return member
            mem_email = _strip_or_none(member.get('email'))
            if mem_email and reg_email_lower and mem_email.lower() == reg_email_lower:
                return member
        return None

    def derive_payment_status(reg_status: Optional[str], documents: List[dict], team_role: Optional[str]) -> str:
        reg_norm = (reg_status or '').lower()
        statuses = [(doc.get('status') or '').lower() for doc in documents]
        success_states = {'succeeded', 'paid'}
        pending_states = {'pending', 'created', 'in_process', 'manual_review', 'requires_action'}
        failure_states = {'failed', 'cancelled', 'cancelled_by_user', 'cancelled_admin', 'expired'}
        if any(state in success_states for state in statuses) or reg_norm == 'paid':
            return 'paid'
        if team_role == 'partner' and reg_norm in {'confirmed', 'invited', 'pending'}:
            return 'covered_by_team'
        if any(state in pending_states for state in statuses) or reg_norm in {'pending_payment'}:
            return 'pending'
        if statuses and all(state in failure_states for state in statuses):
            return 'failed'
        if reg_norm in {'cancelled_by_user', 'cancelled_admin', 'refunded', 'expired'}:
            return 'not_applicable'
        if statuses:
            return statuses[0]
        return 'unpaid'

    def latest_payment(documents: List[dict]) -> Optional[dict]:
        def timestamp(doc: dict) -> Any:
            for key in ('paid_at', 'updated_at', 'created_at'):
                if doc.get(key):
                    return doc.get(key)
            return None
        if not documents:
            return None
        return max(documents, key=lambda d: timestamp(d) or datetime.datetime.fromtimestamp(0, datetime.timezone.utc))

    participants: List[ParticipantOut] = []
    search_norm = _strip_or_none(search)

    for reg in registrations:
        reg_id = str(reg.get('_id'))
        user_id = reg.get('user_id')
        user_doc = users_by_id.get(str(user_id)) if user_id else None
        email = _strip_or_none(reg.get('user_email_snapshot') or (user_doc or {}).get('email'))
        if not user_doc and email and email.lower() in users_by_email:
            user_doc = users_by_email[email.lower()]

        team_id = reg.get('team_id')
        team_doc = teams.get(str(team_id)) if team_id else None
        member_snapshot = resolve_member_snapshot(team_doc, reg, user_doc)

        fn = _strip_or_none((user_doc or {}).get('first_name') or (user_doc or {}).get('firstname'))
        ln = _strip_or_none((user_doc or {}).get('last_name') or (user_doc or {}).get('lastname'))
        if not fn and not ln:
            fallback_name = _strip_or_none((user_doc or {}).get('name')) or _strip_or_none((member_snapshot or {}).get('name'))
            split_fn, split_ln = _split_name(fallback_name)
            fn = fn or split_fn
            ln = ln or split_ln
        full_name = _strip_or_none(' '.join([part for part in [fn, ln] if part]))
        if not full_name:
            full_name = _strip_or_none((member_snapshot or {}).get('name')) or _strip_or_none((user_doc or {}).get('name'))
        if not full_name:
            full_name = email

        gender = _strip_or_none((user_doc or {}).get('gender') or (member_snapshot or {}).get('gender'))
        phone = _strip_or_none((user_doc or {}).get('phone_number') or (member_snapshot or {}).get('phone'))

        diet = _strip_or_none((member_snapshot or {}).get('diet') or reg.get('diet'))
        allergies_raw = None
        if member_snapshot and member_snapshot.get('allergies') is not None:
            allergies_raw = member_snapshot.get('allergies')
        elif user_doc and user_doc.get('allergies') is not None:
            allergies_raw = user_doc.get('allergies')
        elif reg.get('allergies') is not None:
            allergies_raw = reg.get('allergies')
        allergies: List[str] = []
        if isinstance(allergies_raw, list):
            allergies = [str(a).strip() for a in allergies_raw if str(a).strip()]

        team_role = None
        if team_doc:
            creator_id = team_doc.get('created_by_user_id')
            if creator_id and user_id and str(creator_id) == str(user_id):
                team_role = 'creator'
            else:
                team_role = 'partner'

        payments = payments_by_registration.get(reg_id, [])
        payment_status = derive_payment_status(reg.get('status'), payments, team_role)
        latest = latest_payment(payments)
        amount_cents = None
        payment_provider = None
        payment_currency = None
        payment_id = None
        payment_updated_at = None
        if latest:
            payment_provider = _strip_or_none(latest.get('provider'))
            payment_currency = _strip_or_none(latest.get('currency'))
            payment_id = str(latest.get('_id')) if latest.get('_id') else None
            raw_amount = latest.get('amount')
            if raw_amount is not None:
                try:
                    amount_cents = int(round(float(raw_amount) * 100))
                except Exception:
                    amount_cents = None
            payment_updated_at = _isoformat(latest.get('paid_at') or latest.get('updated_at') or latest.get('created_at'))

        participant = ParticipantOut(
            registration_id=reg_id,
            event_id=event_id,
            user_id=str(user_id) if user_id else None,
            email=email,
            first_name=fn,
            last_name=ln,
            full_name=full_name,
            gender=gender,
            phone_number=phone,
            registration_status=reg.get('status'),
            payment_status=payment_status,
            payment_provider=payment_provider,
            payment_amount_cents=amount_cents,
            payment_currency=payment_currency,
            payment_id=payment_id,
            payment_updated_at=payment_updated_at,
            team_id=str(team_id) if team_id else None,
            team_role=team_role,
            team_status=(team_doc or {}).get('status'),
            team_name=_collect_team_label(team_doc, users_by_id),
            diet=diet,
            allergies=allergies,
            created_at=_isoformat(reg.get('created_at')),
            updated_at=_isoformat(reg.get('updated_at')),
        )

        if search_norm:
            haystack = ' '.join(filter(None, [participant.full_name, participant.email, participant.team_name, participant.registration_status, participant.payment_status]))
            if search_norm.lower() not in haystack.lower():
                continue

        participants.append(participant)

    summary = ParticipantsSummary(
        total=len(participants),
    )
    for item in participants:
        pay_key = item.payment_status or 'unknown'
        reg_key = item.registration_status or 'unknown'
        summary.by_payment_status[pay_key] = summary.by_payment_status.get(pay_key, 0) + 1
        summary.by_registration_status[reg_key] = summary.by_registration_status.get(reg_key, 0) + 1

    return ParticipantsResponse(event_id=event_id, participants=participants, summary=summary)
